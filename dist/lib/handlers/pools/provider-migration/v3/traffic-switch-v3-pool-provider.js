import { log, metric, MetricLoggerUnit } from "@votopia/smart-order-router";
import { POOL_PROVIDER_TRAFFIC_SWITCH_CONFIGURATION } from "../../util/pool-provider-traffic-switch-configuration";
import JSBI from "jsbi";
export class TrafficSwitchV3PoolProvider {
    constructor({ currentPoolProvider, targetPoolProvider, sourceOfTruthPoolProvider }) {
        this.SHOULD_SWITCH_TRAFFIC = () => POOL_PROVIDER_TRAFFIC_SWITCH_CONFIGURATION.switchPercentage > this.getRandomPercentage();
        this.SHOULD_SAMPLE_TRAFFIC = () => POOL_PROVIDER_TRAFFIC_SWITCH_CONFIGURATION.samplingPercentage > this.getRandomPercentage();
        this.currentPoolProvider = currentPoolProvider;
        this.targetPoolProvider = targetPoolProvider;
        this.sourceOfTruthPoolProvider = sourceOfTruthPoolProvider;
    }
    getPoolAddress(tokenA, tokenB, feeAmount) {
        // The underlying logic for getting the pool address is always from the
        // source of truth pool provider, and the result is deterministic.
        // It doesn't matter which pool provider we use, so we can start with the target
        // pool provider, which will delegate to the source of truth pool provider.
        return this.targetPoolProvider.getPoolAddress(tokenA, tokenB, feeAmount);
    }
    async getPools(tokenPairs, providerConfig) {
        const sampleTraffic = this.SHOULD_SAMPLE_TRAFFIC();
        const switchTraffic = this.SHOULD_SWITCH_TRAFFIC();
        let currentProviderPools;
        let targetProviderPools;
        metric.putMetric("V3_POOL_PROVIDER_POOL_TRAFFIC_TOTAL", 1, MetricLoggerUnit.None);
        if (sampleTraffic) {
            metric.putMetric("V3_POOL_PROVIDER_POOL_TRAFFIC_SAMPLING", 1, MetricLoggerUnit.None);
            currentProviderPools = await this.currentPoolProvider.getPools(tokenPairs, providerConfig);
            targetProviderPools = await this.targetPoolProvider.getPools(tokenPairs, providerConfig);
            // If we need to sample the traffic, we don't want to make it a blocking I/O
            this.sampleTraffic(tokenPairs, currentProviderPools, targetProviderPools, providerConfig);
        }
        if (switchTraffic) {
            metric.putMetric("V3_POOL_PROVIDER_POOL_TRAFFIC_TARGET", 1, MetricLoggerUnit.None);
            return targetProviderPools !== null && targetProviderPools !== void 0 ? targetProviderPools : (await this.targetPoolProvider.getPools(tokenPairs, providerConfig));
        }
        else {
            metric.putMetric("V3_POOL_PROVIDER_POOL_TRAFFIC_CURRENT", 1, MetricLoggerUnit.None);
            return currentProviderPools !== null && currentProviderPools !== void 0 ? currentProviderPools : (await this.currentPoolProvider.getPools(tokenPairs, providerConfig));
        }
    }
    async sampleTraffic(tokenPairs, currentProviderPools, targetProviderPools, providerConfig) {
        const truthProviderPools = await this.sourceOfTruthPoolProvider.getPools(tokenPairs, providerConfig);
        truthProviderPools.getAllPools().forEach((pool) => {
            const currentProviderPool = currentProviderPools.getPool(pool.token0, pool.token1, pool.fee);
            if (!currentProviderPool) {
                // We don't expect missing pool, but export metric in case we see any
                metric.putMetric("V3_POOL_PROVIDER_POOL_CURRENT_MISSING", 1, MetricLoggerUnit.None);
                log.info(`v3 Pool ${pool.token0.symbol} ${pool.token1.symbol} ${pool.fee} not found in the current pool provider.`);
            }
            else {
                const sameQuote = JSBI.equal(currentProviderPool.sqrtRatioX96, pool.sqrtRatioX96);
                const sameLiquidity = JSBI.equal(currentProviderPool.liquidity, pool.liquidity);
                const accurate = sameQuote && sameLiquidity;
                if (!sameQuote) {
                    log.info(`v3 Pool ${pool.token0.symbol} ${pool.token1.symbol} ${pool.fee} quote mismatch: 
            current ${currentProviderPool.sqrtRatioX96} vs truth ${pool.sqrtRatioX96}.`);
                    metric.putMetric("V3_POOL_PROVIDER_POOL_CURRENT_QUOTE_MISMATCH", 1, MetricLoggerUnit.None);
                }
                if (!sameLiquidity) {
                    log.info(`v3 Pool ${pool.token0.symbol} ${pool.token1.symbol} ${pool.fee} liquidity mismatch: 
            current ${currentProviderPool.liquidity} vs truth ${pool.liquidity}.`);
                    metric.putMetric("V3_POOL_PROVIDER_POOL_CURRENT_LIQUIDITY_MISMATCH", 1, MetricLoggerUnit.None);
                }
                if (!accurate) {
                    metric.putMetric("V3_POOL_PROVIDER_POOL_CURRENT_ACCURACY_MISMATCH", 1, MetricLoggerUnit.None);
                }
                else {
                    metric.putMetric("V3_POOL_PROVIDER_POOL_CURRENT_ACCURACY_MATCH", 1, MetricLoggerUnit.None);
                }
            }
            const targetProviderPool = targetProviderPools.getPool(pool.token0, pool.token1, pool.fee);
            if (!targetProviderPool) {
                // We don't expect missing pool, but export metric in case we see any
                metric.putMetric("V3_POOL_PROVIDER_POOL_TARGET_MISSING", 1, MetricLoggerUnit.None);
                log.info(`v3 Pool ${pool.token0.symbol} ${pool.token1.symbol} ${pool.fee} not found in the target pool provider.`);
            }
            else {
                const sameQuote = JSBI.equal(targetProviderPool.sqrtRatioX96, pool.sqrtRatioX96);
                const sameLiquidity = JSBI.equal(targetProviderPool.liquidity, pool.liquidity);
                const accurate = sameQuote && sameLiquidity;
                if (!sameQuote) {
                    log.info(`v3 Pool ${pool.token0.symbol} ${pool.token1.symbol} ${pool.fee} quote mismatch: 
            target ${targetProviderPool.sqrtRatioX96} vs truth ${pool.sqrtRatioX96}.`);
                    metric.putMetric("V3_POOL_PROVIDER_POOL_TARGET_QUOTE_MISMATCH", 1, MetricLoggerUnit.None);
                }
                if (!sameLiquidity) {
                    log.info(`v3 Pool ${pool.token0.symbol} ${pool.token1.symbol} ${pool.fee} liquidity mismatch: 
            target ${targetProviderPool.liquidity} vs truth ${pool.liquidity}.`);
                    metric.putMetric("V3_POOL_PROVIDER_POOL_TARGET_LIQUIDITY_MISMATCH", 1, MetricLoggerUnit.None);
                }
                if (!accurate) {
                    metric.putMetric("V3_POOL_PROVIDER_POOL_TARGET_ACCURACY_MISMATCH", 1, MetricLoggerUnit.None);
                }
                else {
                    metric.putMetric("V3_POOL_PROVIDER_POOL_TARGET_ACCURACY_MATCH", 1, MetricLoggerUnit.None);
                }
            }
        });
    }
    getRandomPercentage() {
        return Math.floor(Math.random() * 100);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhZmZpYy1zd2l0Y2gtdjMtcG9vbC1wcm92aWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYi9oYW5kbGVycy9wb29scy9wcm92aWRlci1taWdyYXRpb24vdjMvdHJhZmZpYy1zd2l0Y2gtdjMtcG9vbC1wcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQW1CLEdBQUcsRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLEVBQWtCLE1BQU0sNkJBQTZCLENBQUM7QUFJN0csT0FBTyxFQUFFLDBDQUEwQyxFQUFFLE1BQU0sdURBQXVELENBQUM7QUFDbkgsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBUXhCLE1BQU0sT0FBTywyQkFBMkI7SUFVdEMsWUFBWSxFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFLHlCQUF5QixFQUFrQztRQUwvRiwwQkFBcUIsR0FBRyxHQUFHLEVBQUUsQ0FDOUMsMENBQTBDLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFDeEUsMEJBQXFCLEdBQUcsR0FBRyxFQUFFLENBQzlDLDBDQUEwQyxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1FBRzNGLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQztRQUMvQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLENBQUM7UUFDN0MsSUFBSSxDQUFDLHlCQUF5QixHQUFHLHlCQUF5QixDQUFDO0lBQzdELENBQUM7SUFFRCxjQUFjLENBQ1osTUFBYSxFQUNiLE1BQWEsRUFDYixTQUFvQjtRQU1wQix1RUFBdUU7UUFDdkUsa0VBQWtFO1FBQ2xFLGdGQUFnRjtRQUNoRiwyRUFBMkU7UUFDM0UsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDM0Us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LGtCQUFrQixDQUFDLFNBQVMsYUFBYSxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztvQkFFdkUsTUFBTSxDQUFDLFNBQVMsQ0FBQyxpREFBaUQsRUFBRSxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQy9GO2dCQUVELElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ2IsTUFBTSxDQUFDLFNBQVMsQ0FBQyxnREFBZ0QsRUFBRSxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQzlGO3FCQUFNO29CQUNMLE1BQU0sQ0FBQyxTQUFTLENBQUMsNkNBQTZDLEVBQUUsQ0FBQyxFQUFFLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUMzRjthQUNGO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sbUJBQW1CO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDekMsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSVYzUG9vbFByb3ZpZGVyLCBsb2csIG1ldHJpYywgTWV0cmljTG9nZ2VyVW5pdCwgVjNQb29sQWNjZXNzb3IgfSBmcm9tIFwiQHZvdG9waWEvc21hcnQtb3JkZXItcm91dGVyXCI7XG5pbXBvcnQgeyBUb2tlbiwgRmVlQW1vdW50LCBQb29sIH0gZnJvbSBcIkB2b3RvcGlhL3Nkay1jb3JlXCI7XG5cbmltcG9ydCB7IFByb3ZpZGVyQ29uZmlnIH0gZnJvbSBcIkB2b3RvcGlhL3NtYXJ0LW9yZGVyLXJvdXRlci9idWlsZC9tYWluL3Byb3ZpZGVycy9wcm92aWRlclwiO1xuaW1wb3J0IHsgUE9PTF9QUk9WSURFUl9UUkFGRklDX1NXSVRDSF9DT05GSUdVUkFUSU9OIH0gZnJvbSBcIi4uLy4uL3V0aWwvcG9vbC1wcm92aWRlci10cmFmZmljLXN3aXRjaC1jb25maWd1cmF0aW9uXCI7XG5pbXBvcnQgSlNCSSBmcm9tIFwianNiaVwiO1xuXG5leHBvcnQgdHlwZSBUcmFmZmljU3dpdGNoUG9vbFByb3ZpZGVyUHJvcHMgPSB7XG4gIGN1cnJlbnRQb29sUHJvdmlkZXI6IElWM1Bvb2xQcm92aWRlcjtcbiAgdGFyZ2V0UG9vbFByb3ZpZGVyOiBJVjNQb29sUHJvdmlkZXI7XG4gIHNvdXJjZU9mVHJ1dGhQb29sUHJvdmlkZXI6IElWM1Bvb2xQcm92aWRlcjtcbn07XG5cbmV4cG9ydCBjbGFzcyBUcmFmZmljU3dpdGNoVjNQb29sUHJvdmlkZXIgaW1wbGVtZW50cyBJVjNQb29sUHJvdmlkZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGN1cnJlbnRQb29sUHJvdmlkZXI6IElWM1Bvb2xQcm92aWRlcjtcbiAgcHJpdmF0ZSByZWFkb25seSB0YXJnZXRQb29sUHJvdmlkZXI6IElWM1Bvb2xQcm92aWRlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBzb3VyY2VPZlRydXRoUG9vbFByb3ZpZGVyOiBJVjNQb29sUHJvdmlkZXI7XG5cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IFNIT1VMRF9TV0lUQ0hfVFJBRkZJQyA9ICgpID0+XG4gICAgUE9PTF9QUk9WSURFUl9UUkFGRklDX1NXSVRDSF9DT05GSUdVUkFUSU9OLnN3aXRjaFBlcmNlbnRhZ2UgPiB0aGlzLmdldFJhbmRvbVBlcmNlbnRhZ2UoKTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IFNIT1VMRF9TQU1QTEVfVFJBRkZJQyA9ICgpID0+XG4gICAgUE9PTF9QUk9WSURFUl9UUkFGRklDX1NXSVRDSF9DT05GSUdVUkFUSU9OLnNhbXBsaW5nUGVyY2VudGFnZSA+IHRoaXMuZ2V0UmFuZG9tUGVyY2VudGFnZSgpO1xuXG4gIGNvbnN0cnVjdG9yKHsgY3VycmVudFBvb2xQcm92aWRlciwgdGFyZ2V0UG9vbFByb3ZpZGVyLCBzb3VyY2VPZlRydXRoUG9vbFByb3ZpZGVyIH06IFRyYWZmaWNTd2l0Y2hQb29sUHJvdmlkZXJQcm9wcykge1xuICAgIHRoaXMuY3VycmVudFBvb2xQcm92aWRlciA9IGN1cnJlbnRQb29sUHJvdmlkZXI7XG4gICAgdGhpcy50YXJnZXRQb29sUHJvdmlkZXIgPSB0YXJnZXRQb29sUHJvdmlkZXI7XG4gICAgdGhpcy5zb3VyY2VPZlRydXRoUG9vbFByb3ZpZGVyID0gc291cmNlT2ZUcnV0aFBvb2xQcm92aWRlcjtcbiAgfVxuXG4gIGdldFBvb2xBZGRyZXNzKFxuICAgIHRva2VuQTogVG9rZW4sXG4gICAgdG9rZW5COiBUb2tlbixcbiAgICBmZWVBbW91bnQ6IEZlZUFtb3VudFxuICApOiB7XG4gICAgcG9vbEFkZHJlc3M6IHN0cmluZztcbiAgICB0b2tlbjA6IFRva2VuO1xuICAgIHRva2VuMTogVG9rZW47XG4gIH0ge1xuICAgIC8vIFRoZSB1bmRlcmx5aW5nIGxvZ2ljIGZvciBnZXR0aW5nIHRoZSBwb29sIGFkZHJlc3MgaXMgYWx3YXlzIGZyb20gdGhlXG4gICAgLy8gc291cmNlIG9mIHRydXRoIHBvb2wgcHJvdmlkZXIsIGFuZCB0aGUgcmVzdWx0IGlzIGRldGVybWluaXN0aWMuXG4gICAgLy8gSXQgZG9lc24ndCBtYXR0ZXIgd2hpY2ggcG9vbCBwcm92aWRlciB3ZSB1c2UsIHNvIHdlIGNhbiBzdGFydCB3aXRoIHRoZSB0YXJnZXRcbiAgICAvLyBwb29sIHByb3ZpZGVyLCB3aGljaCB3aWxsIGRlbGVnYXRlIHRvIHRoZSBzb3VyY2Ugb2YgdHJ1dGggcG9vbCBwcm92aWRlci5cbiAgICByZXR1cm4gdGhpcy50YXJnZXRQb29sUHJvdmlkZXIuZ2V0UG9vbEFkZHJlc3ModG9rZW5BLCB0b2tlbkIsIGZlZUFtb3VudCk7XG4gIH1cblxuICBhc3luYyBnZXRQb29scyh0b2tlblBhaXJzOiBbVG9rZW4sIFRva2VuLCBGZWVBbW91bnRdW10sIHByb3ZpZGVyQ29uZmlnPzogUHJvdmlkZXJDb25maWcpOiBQcm9taXNlPFYzUG9vbEFjY2Vzc29yPiB7XG4gICAgY29uc3Qgc2FtcGxlVHJhZmZpYyA9IHRoaXMuU0hPVUxEX1NBTVBMRV9UUkFGRklDKCk7XG4gICAgY29uc3Qgc3dpdGNoVHJhZmZpYyA9IHRoaXMuU0hPVUxEX1NXSVRDSF9UUkFGRklDKCk7XG4gICAgbGV0IGN1cnJlbnRQcm92aWRlclBvb2xzO1xuICAgIGxldCB0YXJnZXRQcm92aWRlclBvb2xzO1xuXG4gICAgbWV0cmljLnB1dE1ldHJpYyhcIlYzX1BPT0xfUFJPVklERVJfUE9PTF9UUkFGRklDX1RPVEFMXCIsIDEsIE1ldHJpY0xvZ2dlclVuaXQuTm9uZSk7XG5cbiAgICBpZiAoc2FtcGxlVHJhZmZpYykge1xuICAgICAgbWV0cmljLnB1dE1ldHJpYyhcIlYzX1BPT0xfUFJPVklERVJfUE9PTF9UUkFGRklDX1NBTVBMSU5HXCIsIDEsIE1ldHJpY0xvZ2dlclVuaXQuTm9uZSk7XG5cbiAgICAgIGN1cnJlbnRQcm92aWRlclBvb2xzID0gYXdhaXQgdGhpcy5jdXJyZW50UG9vbFByb3ZpZGVyLmdldFBvb2xzKHRva2VuUGFpcnMsIHByb3ZpZGVyQ29uZmlnKTtcbiAgICAgIHRhcmdldFByb3ZpZGVyUG9vbHMgPSBhd2FpdCB0aGlzLnRhcmdldFBvb2xQcm92aWRlci5nZXRQb29scyh0b2tlblBhaXJzLCBwcm92aWRlckNvbmZpZyk7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIHNhbXBsZSB0aGUgdHJhZmZpYywgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIGl0IGEgYmxvY2tpbmcgSS9PXG4gICAgICB0aGlzLnNhbXBsZVRyYWZmaWModG9rZW5QYWlycywgY3VycmVudFByb3ZpZGVyUG9vbHMsIHRhcmdldFByb3ZpZGVyUG9vbHMsIHByb3ZpZGVyQ29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoc3dpdGNoVHJhZmZpYykge1xuICAgICAgbWV0cmljLnB1dE1ldHJpYyhcIlYzX1BPT0xfUFJPVklERVJfUE9PTF9UUkFGRklDX1RBUkdFVFwiLCAxLCBNZXRyaWNMb2dnZXJVbml0Lk5vbmUpO1xuXG4gICAgICByZXR1cm4gdGFyZ2V0UHJvdmlkZXJQb29scyA/PyAoYXdhaXQgdGhpcy50YXJnZXRQb29sUHJvdmlkZXIuZ2V0UG9vbHModG9rZW5QYWlycywgcHJvdmlkZXJDb25maWcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0cmljLnB1dE1ldHJpYyhcIlYzX1BPT0xfUFJPVklERVJfUE9PTF9UUkFGRklDX0NVUlJFTlRcIiwgMSwgTWV0cmljTG9nZ2VyVW5pdC5Ob25lKTtcblxuICAgICAgcmV0dXJuIGN1cnJlbnRQcm92aWRlclBvb2xzID8/IChhd2FpdCB0aGlzLmN1cnJlbnRQb29sUHJvdmlkZXIuZ2V0UG9vbHModG9rZW5QYWlycywgcHJvdmlkZXJDb25maWcpKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNhbXBsZVRyYWZmaWMoXG4gICAgdG9rZW5QYWlyczogW1Rva2VuLCBUb2tlbiwgRmVlQW1vdW50XVtdLFxuICAgIGN1cnJlbnRQcm92aWRlclBvb2xzOiBWM1Bvb2xBY2Nlc3NvcixcbiAgICB0YXJnZXRQcm92aWRlclBvb2xzOiBWM1Bvb2xBY2Nlc3NvcixcbiAgICBwcm92aWRlckNvbmZpZz86IFByb3ZpZGVyQ29uZmlnXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHRydXRoUHJvdmlkZXJQb29scyA9IGF3YWl0IHRoaXMuc291cmNlT2ZUcnV0aFBvb2xQcm92aWRlci5nZXRQb29scyh0b2tlblBhaXJzLCBwcm92aWRlckNvbmZpZyk7XG5cbiAgICB0cnV0aFByb3ZpZGVyUG9vbHMuZ2V0QWxsUG9vbHMoKS5mb3JFYWNoKChwb29sOiBQb29sKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50UHJvdmlkZXJQb29sID0gY3VycmVudFByb3ZpZGVyUG9vbHMuZ2V0UG9vbChwb29sLnRva2VuMCwgcG9vbC50b2tlbjEsIHBvb2wuZmVlKTtcbiAgICAgIGlmICghY3VycmVudFByb3ZpZGVyUG9vbCkge1xuICAgICAgICAvLyBXZSBkb24ndCBleHBlY3QgbWlzc2luZyBwb29sLCBidXQgZXhwb3J0IG1ldHJpYyBpbiBjYXNlIHdlIHNlZSBhbnlcbiAgICAgICAgbWV0cmljLnB1dE1ldHJpYyhcIlYzX1BPT0xfUFJPVklERVJfUE9PTF9DVVJSRU5UX01JU1NJTkdcIiwgMSwgTWV0cmljTG9nZ2VyVW5pdC5Ob25lKTtcbiAgICAgICAgbG9nLmluZm8oXG4gICAgICAgICAgYHYzIFBvb2wgJHtwb29sLnRva2VuMC5zeW1ib2x9ICR7cG9vbC50b2tlbjEuc3ltYm9sfSAke3Bvb2wuZmVlfSBub3QgZm91bmQgaW4gdGhlIGN1cnJlbnQgcG9vbCBwcm92aWRlci5gXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzYW1lUXVvdGUgPSBKU0JJLmVxdWFsKGN1cnJlbnRQcm92aWRlclBvb2wuc3FydFJhdGlvWDk2LCBwb29sLnNxcnRSYXRpb1g5Nik7XG4gICAgICAgIGNvbnN0IHNhbWVMaXF1aWRpdHkgPSBKU0JJLmVxdWFsKGN1cnJlbnRQcm92aWRlclBvb2wubGlxdWlkaXR5LCBwb29sLmxpcXVpZGl0eSk7XG4gICAgICAgIGNvbnN0IGFjY3VyYXRlID0gc2FtZVF1b3RlICYmIHNhbWVMaXF1aWRpdHk7XG5cbiAgICAgICAgaWYgKCFzYW1lUXVvdGUpIHtcbiAgICAgICAgICBsb2cuaW5mbyhgdjMgUG9vbCAke3Bvb2wudG9rZW4wLnN5bWJvbH0gJHtwb29sLnRva2VuMS5zeW1ib2x9ICR7cG9vbC5mZWV9IHF1b3RlIG1pc21hdGNoOiBcbiAgICAgICAgICAgIGN1cnJlbnQgJHtjdXJyZW50UHJvdmlkZXJQb29sLnNxcnRSYXRpb1g5Nn0gdnMgdHJ1dGggJHtwb29sLnNxcnRSYXRpb1g5Nn0uYCk7XG5cbiAgICAgICAgICBtZXRyaWMucHV0TWV0cmljKFwiVjNfUE9PTF9QUk9WSURFUl9QT09MX0NVUlJFTlRfUVVPVEVfTUlTTUFUQ0hcIiwgMSwgTWV0cmljTG9nZ2VyVW5pdC5Ob25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2FtZUxpcXVpZGl0eSkge1xuICAgICAgICAgIGxvZy5pbmZvKGB2MyBQb29sICR7cG9vbC50b2tlbjAuc3ltYm9sfSAke3Bvb2wudG9rZW4xLnN5bWJvbH0gJHtwb29sLmZlZX0gbGlxdWlkaXR5IG1pc21hdGNoOiBcbiAgICAgICAgICAgIGN1cnJlbnQgJHtjdXJyZW50UHJvdmlkZXJQb29sLmxpcXVpZGl0eX0gdnMgdHJ1dGggJHtwb29sLmxpcXVpZGl0eX0uYCk7XG5cbiAgICAgICAgICBtZXRyaWMucHV0TWV0cmljKFwiVjNfUE9PTF9QUk9WSURFUl9QT09MX0NVUlJFTlRfTElRVUlESVRZX01JU01BVENIXCIsIDEsIE1ldHJpY0xvZ2dlclVuaXQuTm9uZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFjY3VyYXRlKSB7XG4gICAgICAgICAgbWV0cmljLnB1dE1ldHJpYyhcIlYzX1BPT0xfUFJPVklERVJfUE9PTF9DVVJSRU5UX0FDQ1VSQUNZX01JU01BVENIXCIsIDEsIE1ldHJpY0xvZ2dlclVuaXQuTm9uZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0cmljLnB1dE1ldHJpYyhcIlYzX1BPT0xfUFJPVklERVJfUE9PTF9DVVJSRU5UX0FDQ1VSQUNZX01BVENIXCIsIDEsIE1ldHJpY0xvZ2dlclVuaXQuTm9uZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0UHJvdmlkZXJQb29sID0gdGFyZ2V0UHJvdmlkZXJQb29scy5nZXRQb29sKHBvb2wudG9rZW4wLCBwb29sLnRva2VuMSwgcG9vbC5mZWUpO1xuICAgICAgaWYgKCF0YXJnZXRQcm92aWRlclBvb2wpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgZXhwZWN0IG1pc3NpbmcgcG9vbCwgYnV0IGV4cG9ydCBtZXRyaWMgaW4gY2FzZSB3ZSBzZWUgYW55XG4gICAgICAgIG1ldHJpYy5wdXRNZXRyaWMoXCJWM19QT09MX1BST1ZJREVSX1BPT0xfVEFSR0VUX01JU1NJTkdcIiwgMSwgTWV0cmljTG9nZ2VyVW5pdC5Ob25lKTtcbiAgICAgICAgbG9nLmluZm8oXG4gICAgICAgICAgYHYzIFBvb2wgJHtwb29sLnRva2VuMC5zeW1ib2x9ICR7cG9vbC50b2tlbjEuc3ltYm9sfSAke3Bvb2wuZmVlfSBub3QgZm91bmQgaW4gdGhlIHRhcmdldCBwb29sIHByb3ZpZGVyLmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNhbWVRdW90ZSA9IEpTQkkuZXF1YWwodGFyZ2V0UHJvdmlkZXJQb29sLnNxcnRSYXRpb1g5NiwgcG9vbC5zcXJ0UmF0aW9YOTYpO1xuICAgICAgICBjb25zdCBzYW1lTGlxdWlkaXR5ID0gSlNCSS5lcXVhbCh0YXJnZXRQcm92aWRlclBvb2wubGlxdWlkaXR5LCBwb29sLmxpcXVpZGl0eSk7XG4gICAgICAgIGNvbnN0IGFjY3VyYXRlID0gc2FtZVF1b3RlICYmIHNhbWVMaXF1aWRpdHk7XG5cbiAgICAgICAgaWYgKCFzYW1lUXVvdGUpIHtcbiAgICAgICAgICBsb2cuaW5mbyhgdjMgUG9vbCAke3Bvb2wudG9rZW4wLnN5bWJvbH0gJHtwb29sLnRva2VuMS5zeW1ib2x9ICR7cG9vbC5mZWV9IHF1b3RlIG1pc21hdGNoOiBcbiAgICAgICAgICAgIHRhcmdldCAke3RhcmdldFByb3ZpZGVyUG9vbC5zcXJ0UmF0aW9YOTZ9IHZzIHRydXRoICR7cG9vbC5zcXJ0UmF0aW9YOTZ9LmApO1xuXG4gICAgICAgICAgbWV0cmljLnB1dE1ldHJpYyhcIlYzX1BPT0xfUFJPVklERVJfUE9PTF9UQVJHRVRfUVVPVEVfTUlTTUFUQ0hcIiwgMSwgTWV0cmljTG9nZ2VyVW5pdC5Ob25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2FtZUxpcXVpZGl0eSkge1xuICAgICAgICAgIGxvZy5pbmZvKGB2MyBQb29sICR7cG9vbC50b2tlbjAuc3ltYm9sfSAke3Bvb2wudG9rZW4xLnN5bWJvbH0gJHtwb29sLmZlZX0gbGlxdWlkaXR5IG1pc21hdGNoOiBcbiAgICAgICAgICAgIHRhcmdldCAke3RhcmdldFByb3ZpZGVyUG9vbC5saXF1aWRpdHl9IHZzIHRydXRoICR7cG9vbC5saXF1aWRpdHl9LmApO1xuXG4gICAgICAgICAgbWV0cmljLnB1dE1ldHJpYyhcIlYzX1BPT0xfUFJPVklERVJfUE9PTF9UQVJHRVRfTElRVUlESVRZX01JU01BVENIXCIsIDEsIE1ldHJpY0xvZ2dlclVuaXQuTm9uZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFjY3VyYXRlKSB7XG4gICAgICAgICAgbWV0cmljLnB1dE1ldHJpYyhcIlYzX1BPT0xfUFJPVklERVJfUE9PTF9UQVJHRVRfQUNDVVJBQ1lfTUlTTUFUQ0hcIiwgMSwgTWV0cmljTG9nZ2VyVW5pdC5Ob25lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXRyaWMucHV0TWV0cmljKFwiVjNfUE9PTF9QUk9WSURFUl9QT09MX1RBUkdFVF9BQ0NVUkFDWV9NQVRDSFwiLCAxLCBNZXRyaWNMb2dnZXJVbml0Lk5vbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdldFJhbmRvbVBlcmNlbnRhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKTtcbiAgfVxufVxuIl19